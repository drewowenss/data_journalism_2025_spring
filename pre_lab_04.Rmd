---
title: "pre_lab_04.Rmd"
author: "Derek Willis"
date: "2024-09-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Instructor demonstration points to hit

1.  Ensure students install refinr package and load it.
2.  Show students how to download and install Open Refine and confirm install before they leave class.

## Chapter 16

### Task 1: Install refinr package

**Task** Run the following code in the gray-colored codeblock below to install refinr.

```{r}
install.packages('refinr')
```

### Task 2: Load libraries and settings

**Task** Run the following code in the gray-colored codeblock below to load the tidyverse, janitor, and refinr and turn off scientific notation.

```{r}
# turn off sci notation
options(scipen=999)
library(tidyverse)
library(lubridate)
library(refinr)
```

### Task 3: Load data

**Task** Run the following code to load some campaign expenditure data focused on food-related expenses in Washington, D.C. **Answer**

```{r}
# Load data
dc_food <- read_csv("data/dc_food.csv")

# Display it
dc_food

```

### Task 4: Group and count to identify problems in city column

**Task** Run the following code to group and count records in the recipient_name column, and filter to examine only recipients that start with W. Name a problem that you see that is preventing proper grouping. 

#A problem that I am seeing is that after opening refinr, we have multiple recipient names that look the same, but have something different. Like we have W. Millar and CO. and W. Millar and CO without the period. And we also used str_detect for both W, and w, when we should have used different ones for each. 

```{r}
# Now let's try and group and count the number of expenditures by recipient. To make it a bit more manageable, let's use another string function from `stringr` and filter for recipients that start with the uppercase "W" or lowercase "w" using the function `str_detect()` with a regular expression.  

# The filter function in the codeblock below says: look in the city column, and pluck out any value that starts with (the "^" symbol means "starts with") a lowercase "w" OR (the vertical "|", called a pipe, means OR) an uppercase "W". 

dc_food |>
  group_by(recipient_name) |>
  summarise(
    count=n()
  ) |>
  filter(str_detect(recipient_name, '^w|^W')) |> 
  arrange(recipient_name)
```

### Task 5: Use refinr to clean the city_clean field.

**Task** Run the following code to make a copy of the recipient_name field called recipient_clean, then use the `key_collision_merge` function from refinr to attempt to standarize similar values. Store it as a new object called cleaned_dc_food. Click the black arrow on the table to examine the recipient_name and recipient_clean columns. Looking at the results on the first two pages only (first 20 rows), name two changes the refinr package made, by comparing recipient_name to recipient_clean. 

#Two changes that they made were that the date was mutated, to clean it up, making recipient_clean equal to key_collison_merge, which takes the keys and extracts the parts of the date. The second change I see is how they select the recipient name, where you are selecting essentially what you want to clean up. 

```{r}
cleaned_dc_food <- dc_food |>
  mutate(recipient_clean=key_collision_merge(recipient_name)) |>
  select(recipient_name, recipient_clean, everything())

cleaned_dc_food

```

### Task 6: Filter cleaned_dc_food to examine recipients that start with W

**Task** Run the following code to group by recipient_clean and recipient_name, then filter for cities that start with W. Name three changes the refinr function made in the first 20 results. 

#1. It cleanedup the names of recipient clean so that names that do not look identical like WALMART and Walmart are under the same recipient clean. 2. There is now a count column, counting how many duplicates or more are in the data set. 3. We filter recipient clean under str_detect, so that it starts with an W.

```{r}
cleaned_dc_food |>
  group_by(recipient_name, recipient_clean) |>
  summarise(
    count=n()
  ) |>
  filter(str_detect(recipient_clean, "^w|^W")) |>
  arrange(recipient_clean)
```

### Task 7: Use a different refinr method to clean the city_clean field.

**Task** Run the following code to use the n_gram_merge() function to clean the data, then group by city_clean and city to examine cities that start with A. Look at the differences. Does the changes it made vary substantially from the previous use of key_collision_merge?  
**Answer** Not really, both n_gram_merge() and key_collision_merge() do the same things, and even though sometimes it can fix certain changes, I see nothing. 
```{r}
cleaned_dc_food <- dc_food |>
  mutate(recipient_clean=n_gram_merge(recipient_name)) |>
  select(recipient_name, recipient_clean, everything())

cleaned_dc_food


cleaned_dc_food |>
  group_by(recipient_name, recipient_clean) |>
  summarise(
    count=n()
  ) |>
  filter(str_detect(recipient_clean, "^w|^W")) |>
  arrange(recipient_clean)


```

### Task 8: Follow the directions in the textbook to use Open Refine

**Task** Follow the directions in the textbook to upload dc_food.csv to Open Refine (<https://thescoop.org/data_journalism_book/open-refine.html#manually-cleaning-data-with-open-refine>). Follow the instructions to clean as many recipients as the Open Refine clustering tool can identify. In class, I will come around to look at the Open Refine project you created to do this.
